import re
import os
import pandas as pd
import numpy as np
# from math import log10
from typing import Dict, Tuple, Optional

from .utils import timer

pd.options.mode.chained_assignment = None

@timer
def get_sweep_data(data_dir: str, params: dict) -> pd.DataFrame:
    '''Get dataframe with all data resulting from a double parameter sweep of
    'screen-analyzer analyze'.

    Dataframe example:

    gene_name	low_counts	high_counts	    p	    p_fdr	    log2_mi
    A1BG	    1	        0	            1.0	    1.03441	    0.049043

    start	    end	        srt_pos	    end_pos	    srt_off	    end_off
    tx-2000	    tx-9500	    tx	        tx	        -2000	    -9500

    Arguments:
    data_dir: str eg. 'data/screen-analyzer-data'

    params: dict eg {'screen_name': 'PDL1_IFNg',
                     'assembly': 'hg38',
                     'trim_length': '50',
                     'mode': 'collapse',
                     'start': 'tx',
                     'end': 'tx',
                     'overlap': 'both',
                     'direction': 'sense',
                     'step': 500}
    '''

    data_path = (f'''{data_dir}/{params['screen_name']}/'''
                 f'''{params['assembly']}/{params['trim_length']}/'''
                 f'''mode={params['mode']}_direction={params['direction']}'''
                 f'''_overlap={params['overlap']}/double-sweep'''
                 f'''_step={params['step']}/''')

    files = os.listdir(data_path)
    df_list = []  # Initialize list to append data
    for filename in files:

        if filename.startswith('out'):
            # Get param values from filename
            match = re.search(r'_start=(.*?)_', filename)
            start = match.group(1)
            match = re.search(r'_end=(.*?)_', filename)
            end = match.group(1)

            # File to df, add columns for each param value and add to list
            df = pd.read_csv(data_path + filename, sep='\t',
                             index_col=None, header=None)
            df[6] = start
            df[7] = end
            df_list.append(df)

    # Create single dataframe from list
    sweep_data = pd.concat(df_list, axis=0, ignore_index=True)
    sweep_data = sweep_data.rename(columns={0: 'gene_name', 1: 'low_counts',
                                            2: 'high_counts', 3: 'p',
                                            4: 'p_fdr', 5: 'log2_mi',
                                            6: 'start', 7: 'end'})

    # Trandform parameter into numbers, eg. 'tx-100' is changed to column
    # 'offset' with value -100:int
    sweep_data[['srt_off', 'end_off']] = sweep_data[['start', 'end']].applymap(
        lambda x: ''.join(re.split('(-|\\+)', x)[1:3])).astype(np.int16)

    # Rearrange and change data types
    sweep_data = sweep_data.sort_values(by=['gene_name', 'srt_off', 'end_off'])
    sweep_data = sweep_data.drop(['start', 'end'], axis=1)

    int_cols = ['low_counts', 'high_counts', 'srt_off', 'end_off']
    sweep_data[int_cols] = (sweep_data[int_cols]
                            .apply(lambda x:
                                   pd.to_numeric(x, downcast='integer')))

    float_cols = ['p', 'p_fdr', 'log2_mi']
    sweep_data[float_cols] = (sweep_data[float_cols]
                              .apply(lambda x:
                                     pd.to_numeric(x, downcast='float')))

    return sweep_data


@ timer
def write_sweep_data(data_dir: str, sweep_data: pd.DataFrame,
                     params: dict) -> dict:
    '''Writes compressed file containing all data from dataframe
    'sweep_data' generated by 'get_sweep_data' plus 4 additional columns that
    include data on how log2_mi and p_fdr change as parameters 'start' and
    'end' vary. Also returns dictionary were keys are gene names and values
    are dataframes with the data for the given gene.

    The 4 new columns are: 'sl_sdir', 'sl_edir', 'p_ratio_sdir', and
    'p_ratio_edir'.

    'sl_sdir' and 'sl_edir' represent the change in log2_mi when changing
    the start parameter ('sdir': start direction) or the end parameter
    ('edir': end direction) by 1,000 bp. Ie.
    ((log2_mi at param i+1) - (log2_mi at param i)) / (step size in bp * 0.001)

    'p_ratio_sdir' and 'p_ratio_edir' represent the log10 of the p_fdr ratio
    when changing the start or end parameters by 1,000 bp. Ie.
    log10 ((p_fdr at param i+1)/(p_fdr at param i)) / (step size in bp * 0.001)
    '''

    data_path = (f'''{data_dir}/{params['screen_name']}/'''
                 f'''{params['assembly']}/{params['trim_length']}/'''
                 f'''mode={params['mode']}_direction={params['direction']}'''
                 f'''_overlap={params['overlap']}/double-sweep'''
                 f'''_step={params['step']}/''')

    if not os.path.exists(data_path):
        os.makedirs(data_path)
        print('Creating analyzed directory.')

    gene_info = dict()
    grouped = sweep_data.groupby('gene_name')
    for name, group in grouped:

        print(name)

        gene_data = group.pivot(index='srt_off', columns='end_off',
                                values=['gene_name', 'low_counts',
                                        'high_counts', 'p', 'p_fdr',
                                        'log2_mi'])

        # Get slopes of log2 MI when changing parameters in both directions
        # (delta log2 MI per 1,000 bp)
        slope_sdir = (gene_data['log2_mi']
                      - gene_data['log2_mi'].shift(1))/(params['step']*0.001)
        slope_edir = (gene_data['log2_mi']
                      - gene_data['log2_mi'].shift(1,
                                                   axis=1))/(params['step']
                                                             * 0.001)

        # Get minimum p-value between consecutive parameters in both start
        # and end directions
        shift_sdir = gene_data['p_fdr'].shift(1)
        shift_sdir.columns = pd.MultiIndex.from_arrays(
            [tuple('p_shift_sdir' for x in shift_sdir.columns),
             tuple(x for x in shift_sdir.columns)])
        gene_data = pd.concat([gene_data, shift_sdir], ignore_index=False,
                              axis=1)

        shift_edir = gene_data['p_fdr'].shift(1, axis=1)
        shift_edir.columns = pd.MultiIndex.from_arrays(
            [tuple('p_shift_edir' for x in shift_edir.columns),
             tuple(x for x in shift_edir.columns)])
        gene_data = pd.concat([gene_data, shift_edir], ignore_index=False,
                              axis=1)

        # Stack data and add columns
        gene_data = gene_data.stack()

        gene_data['p_min_sdir'] = gene_data[['p_fdr',
                                             'p_shift_sdir']].min(axis=1)
        gene_data['p_min_edir'] = gene_data[['p_fdr',
                                             'p_shift_edir']].min(axis=1)
        gene_data = gene_data.drop(columns=['p_shift_sdir', 'p_shift_edir'])

        gene_data['sl_sdir'] = slope_sdir.stack()
        gene_data['sl_edir'] = slope_edir.stack()

        gene_data = gene_data[gene_data.gene_name.notnull()]

        gene_info[name] = gene_data

    all_info = pd.concat(gene_info.values(), ignore_index=False)

    int_cols = ['low_counts', 'high_counts']
    all_info[int_cols] = (all_info[int_cols]
                          .apply(lambda x:
                                 pd.to_numeric(x, downcast='integer')))
    float_cols = ['p', 'p_fdr', 'log2_mi', 'sl_sdir', 'sl_edir']
    all_info[float_cols] = (all_info[float_cols]
                            .apply(lambda x:
                                   pd.to_numeric(x, downcast='float')))

    # all_info.to_csv(f'{data_path}all_gene_info_csv.gz',
    #                 compression='gzip')
    all_info.to_parquet(f'{data_path}all_gene_info.parquet.snappy',
                        engine='pyarrow', compression='snappy')

    return all_info


@ timer
def read_analyzed_sweep(data_dir: str,
                        params: dict) -> \
        pd.core.groupby.generic.DataFrameGroupBy:
    '''Reads compressed file created by 'write_sweep_data' containing
    the all data from sweeping the start and end paramenters with the
    screen-analyzer. Returns pandas dataframe grouped by gene name.

    data_dir: str eg. 'data/analyzed-data'
    params: dict eg {'screen_name': 'PDL1_IFNg',
                     'assembly': 'hg38',
                     'trim_length': '50',
                     'mode': 'collapse',
                     'start': 'tx',
                     'end': 'tx',
                     'overlap': 'both',
                     'direction': 'sense',
                     'step': 500}
    '''

    data_file = (f'''{data_dir}/{params['screen_name']}/'''
                 f'''{params['assembly']}/{params['trim_length']}/'''
                 f'''mode={params['mode']}_direction={params['direction']}'''
                 f'''_overlap={params['overlap']}/double-sweep'''
                 f'''_step={params['step']}/all_gene_info''')

    # sweep = pd.read_csv(f'{data_file}_csv.gz', compression='gzip')
    sweep = pd.read_parquet(f'{data_file}.parquet.snappy',
                            engine='pyarrow')

    # sweep = sweep.set_index(keys=['srt_off', 'end_off'])
    grouped_sweep = sweep.groupby('gene_name')

    return grouped_sweep


def get_gene_info(gene: str,
                  grouped_sweep: pd.core.groupby.generic.DataFrameGroupBy) -> \
        pd.DataFrame:
    '''Given a grouped_sweep created by 'read_analyzed_sweep', returns
    unstacked dataframe containing all sweep data for a given gene.
    '''
    gene = gene.upper()
    gene_info = grouped_sweep.get_group(gene)

    return gene_info.unstack()


@ timer
def get_flagged_genes(grouped_sweep: pd.core.groupby.generic.DataFrameGroupBy,
                      p_thr: float,
                      slope_thr: float,
                      p_ratio_thr: float) -> Tuple[Dict[str, pd.DataFrame],
                                                   Dict[str, pd.DataFrame]]:
    '''Given a grouped_sweep created by 'read_analyzed_sweep', finds genes
    that have a higher slope and p ratio than the thresholds given by
    'slope_thr' and 'p_ratio_thr'.
    Slope refers to the change in the log2 mutation index per 1,000 bp.
    P ratio refers to the change in the log10 p fdr per 1,000 bp.
    Returns tuple with two dictionaries, where keys are gene names and values
    are subsets of dataframe where both thresholds are passed when changing
    either the start or the end parameter, respectively.
    '''

    flagged_sdir = dict()
    flagged_edir = dict()
    ct = 0
    for name, group in grouped_sweep:

        if not group.query('p_fdr < @p_thr').empty:

            flags_sdir = group.query(flags_query('start'))
            flags_edir = group.query(flags_query('end'))

            if not flags_sdir.empty:
                # print('start dir - ', name)
                flagged_sdir[name] = flags_sdir

            if not flags_edir.empty:
                # print('end dir - ', name)
                flagged_edir[name] = flags_edir

            if not flags_sdir.empty or not flags_edir.empty:
                ct += 1
                print(f'Flagged: {name}')

    print(f'\n# flagged genes: {ct} -- # start flags: {len(flagged_sdir)} -- '
          f'# end flags: {len(flagged_edir)}')

    return (flagged_sdir, flagged_edir)


def get_flags_for_gene(gene: str,
                       grouped_sweep: pd.core.groupby.generic.DataFrameGroupBy,
                       p_thr: Optional[float] = None,
                       slope_thr: Optional[float] = None,
                       p_ratio_thr: Optional[float] = None) -> Tuple[
        pd.DataFrame, pd.DataFrame]:

    p_thr = p_thr or 0.00001
    slope_thr = slope_thr or 2
    p_ratio_thr = p_ratio_thr or 20

    gene_info = get_gene_info(gene, grouped_sweep).stack()
    flags_sdir = pd.DataFrame()
    flags_edir = pd.DataFrame()
    if not gene_info.query('p_fdr < @p_thr').empty:
        flags_sdir = gene_info.query(flags_query('start'))
        flags_edir = gene_info.query(flags_query('end'))

    return (flags_sdir, flags_edir)


def flags_query(param: str) -> str:
    '''Return string to use for querying flagged genes. Param: 'start' or
    'end'.
    '''

    # q = (f'abs(sl_{param[0]}dir) > @slope_thr '
    #      f'| abs(p_ratio_{param[0]}dir) > @p_ratio_thr')

    # q = (f'abs(sl_{param[0]}dir) > @slope_thr')
    # q = (f'abs(p_ratio_{param[0]}dir) > @p_ratio_thr')

    q = (f'abs(sl_{param[0]}dir) > @slope_thr '
         f'& p_min_{param[0]}dir < @p_thr')

    return q
