import re
import os
import pandas as pd
from math import log10
from typing import Dict, Tuple

from utils import timer

@timer
def get_sweep_data(data_dir: str, params: dict) -> pd.DataFrame:
    '''Get dataframe with all data resulting from a double parameter sweep of
    'screen-analyzer analyze'.

    Dataframe example:

    gene_name	low_counts	high_counts	    p	    p_fdr	    log2_mi	
    A1BG	    1	        0	            1.0	    1.03441	    0.049043

    start	    end	        srt_pos	    end_pos	    srt_off	    end_off
    tx-2000	    tx-9500	    tx	        tx	        -2000	    -9500   

    Arguments:
    data_dir: str eg. 'data/screen-analyzer-data'

    params: dict eg {'screen_name': 'PDL1_IFNg',
                     'assembly': 'hg38',
                     'trim_length': '50',
                     'mode': 'collapse',
                     'start': 'tx',
                     'end': 'tx',
                     'overlap': 'both',
                     'direction': 'sense',
                     'step': 500}
    '''

    data_path = (f'''{data_dir}/{params['screen_name']}/'''
                f'''{params['assembly']}/{params['trim_length']}/'''
                f'''mode={params['mode']}_direction={params['direction']}'''
                f'''_overlap={params['overlap']}/double-sweep'''
                f'''_step={params['step']}/''')

    files = os.listdir(data_path)
    df_list = []  # Initialize list to append data
    for filename in files:

        if filename.startswith('out'):
            # Get param values from filename
            match = re.search(rf'_start=(.*?)_', filename)
            start = match.group(1)
            match = re.search(rf'_end=(.*?)_', filename)
            end = match.group(1)
        
            # File to df, add columns for each param value and add to list
            df = pd.read_csv(data_path + filename, sep='\t',
                                index_col=None, header=None)
            df[6] = start
            df[7] = end
            df_list.append(df)

    # Create single dataframe from list
    sweep_data = pd.concat(df_list, axis=0, ignore_index=True)
    sweep_data = sweep_data.rename(columns={0: 'gene_name', 1: 'low_counts',
                                            2: 'high_counts', 3: 'p',
                                            4: 'p_fdr', 5: 'log2_mi',
                                            6: 'start', 7: 'end'})

    # Split parameter values into txt and numbers, creating one column for each
    # eg. 'tx-100' is split in column 'position' with value 'tx':str and column
    # 'offset' with value -100:int
    sweep_data[['srt_pos', 'end_pos']] = sweep_data[['start', 'end']].applymap(
        lambda x: re.split('(-|\\+)', x)[0])
    sweep_data[['srt_off', 'end_off']] = sweep_data[['start', 'end']].applymap(
        lambda x: ''.join(re.split('(-|\\+)', x)[1:3])).astype(int)

    # Sort by name and offsets
    sweep_data = sweep_data.sort_values(by=['gene_name', 'srt_off', 'end_off'])

    return sweep_data

@timer
def write_sweep_data(data_dir: str, sweep_data: pd.DataFrame, 
                     params: dict) -> dict:
    '''Writes compressed csv file containing all data from dataframe 
    'sweep_data' generated by 'get_sweep_data' plus 4 additional columns that
    include data on how log2_mi and p_fdr change as parameters 'start' and
    'end' vary. Also returns dictionary were keys are gene names and values
    are dataframes with the data for the given gene.
    
    The 4 new columns are: 'sl_sdir', 'sl_edir', 'p_ratio_sdir', and
    'p_ratio_edir'.

    'sl_sdir' and 'sl_edir' represent the change in log2_mi when changing
    the start parameter ('sdir': start direction) or the end parameter 
    ('edir': end direction) by 1,000 bp. Ie. 
    ((log2_mi at param i+1) - (log2_mi at param i)) / (step size in bp * 0.001)

    'p_ratio_sdir' and 'p_ratio_edir' represent the log10 of the p_fdr ratio
    when changing the start or end parameters by 1,000 bp. Ie. 
    log10 ((p_fdr at param i+1)/(p_fdr at param i)) / (step size in bp * 0.001)
    '''

    data_path = (f'''{data_dir}/{params['screen_name']}/'''
                f'''{params['assembly']}/{params['trim_length']}/'''
                f'''mode={params['mode']}_direction={params['direction']}'''
                f'''_overlap={params['overlap']}/double-sweep'''
                f'''_step={params['step']}/''')
    
    if not os.path.exists(data_path):
        os.makedirs(data_path)
        print('Creating analyzed directory.')
    
    gene_info = dict()

    grouped = sweep_data.groupby('gene_name')
    for name, group in grouped:

        print(name)
        
        gene_data = group.pivot(index='srt_off', columns='end_off', 
                    values=['gene_name', 'low_counts', 'high_counts', 'p',
                            'p_fdr','log2_mi', 'srt_pos', 'end_pos'])

        # Get slopes of log2 MI when changing parameters in both directions 
        # (delta log2 MI per 1,000 bp)
        slope_sdir = (gene_data['log2_mi'] 
                      - gene_data['log2_mi'].shift(1))/(params['step']*0.001)

        slope_edir = (gene_data['log2_mi'] 
                      - gene_data['log2_mi'].shift(1, 
                                             axis=1))/(params['step']*0.001)

        # Get log10 of ratio of p values when changing parameters in 
        # both directions (per 1,000 bp)
        gene_data['p_fdr'] = gene_data['p_fdr'].replace(0, 1e-300)
        p_ratio_sdir = ((gene_data['p_fdr']/
                        gene_data['p_fdr'].shift(1)).applymap(log10)
                        /(params['step']*0.001))
        p_ratio_edir = ((gene_data['p_fdr']/
                        gene_data['p_fdr'].shift(1, axis=1)).applymap(log10)
                        /(params['step']*0.001))

        gene_data = gene_data.stack()
        gene_data['sl_sdir'] = slope_sdir.stack()
        gene_data['sl_edir'] = slope_edir.stack()
        gene_data['p_ratio_sdir'] = p_ratio_sdir.stack()
        gene_data['p_ratio_edir'] = p_ratio_edir.stack()
    
        gene_info[name] = gene_data

    all_info = pd.concat(gene_info.values(), ignore_index=False)
    all_info.to_csv(f'{data_path}all_gene_info.gz', 
                    compression='gzip')

    return gene_info

@timer
def read_analyzed_sweep(data_dir: str,
                        params: dict) -> \
                        pd.core.groupby.generic.DataFrameGroupBy:
    '''Reads compressed csv file created by 'write_sweep_data' containing
    the all data from sweeping the start and end paramenters with the
    screen-analyzer. Returns pandas dataframe grouped by gene name.

    data_dir: str eg. 'data/analyzed-data'
    params: dict eg {'screen_name': 'PDL1_IFNg',
                     'assembly': 'hg38',
                     'trim_length': '50',
                     'mode': 'collapse',
                     'start': 'tx',
                     'end': 'tx',
                     'overlap': 'both',
                     'direction': 'sense',
                     'step': 500}
    '''

    data_file = (f'''{data_dir}/{params['screen_name']}/'''
                 f'''{params['assembly']}/{params['trim_length']}/'''
                 f'''mode={params['mode']}_direction={params['direction']}'''
                 f'''_overlap={params['overlap']}/double-sweep'''
                 f'''_step={params['step']}/all_gene_info''')

    sweep = pd.read_csv(f'{data_file}.gz', compression='gzip')
    sweep = sweep.set_index(keys=['srt_off', 'end_off'])
    grouped_sweep = sweep.groupby('gene_name')

    return grouped_sweep

@timer
def get_flagged_genes(grouped_sweep: pd.core.groupby.generic.DataFrameGroupBy,
                      slope_thr: float, 
                      p_ratio_thr: float) -> Tuple[Dict[str, pd.DataFrame], 
                                             Dict[str, pd.DataFrame]]:
    '''Given a grouped_sweep created by 'read_analyzed_sweep', finds genes
    that have a higher slope and p ratios than a threshold given by 
    'slope_thr' and 'p_ratio_thr'. 
    Slope refers to the change in the log2 mutation index per 1,000 bp.
    P ratio refers to the change in the log10 p fdr per 1,000 bp.
    Returns tuple with two dictionaries, where keys are gene names and values
    are subsets of dataframe where thresholds are passed when changing either 
    the start or the end parameter, respectively.
    '''

    flagged_sdir = dict()
    flagged_edir = dict()
    for name, group in grouped_sweep:

        flags_sdir = group.query('abs(sl_sdir) > @slope_thr '
                                 '& abs(p_ratio_sdir) > @p_ratio_thr')
        flags_edir = group.query('abs(sl_edir) > @slope_thr '
                                 '& abs(p_ratio_edir) > @p_ratio_thr')

        if not flags_sdir.empty:
            print('start dir - ', name)
            flagged_sdir[name] = flags_sdir

        if not flags_edir.empty:
            print('end dir - ', name)
            flagged_edir[name] = flags_edir

    return (flagged_sdir, flagged_edir)

@timer
def get_gene_inf(gene: str, 
                 grouped_sweep: pd.core.groupby.generic.DataFrameGroupBy) -> \
                 pd.DataFrame:
    '''Given a grouped_sweep created by 'read_analyzed_sweep', returns
    dataframe containing all sweep data for a given gene.
    '''
    gene = gene.upper()
    grouped_sweep.get_group(gene)